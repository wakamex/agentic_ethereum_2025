What's up guys? My name is Kevin Jones. I am a developer relations engineer working on the graph protocol. And today I'm going to be talking to you about the graph and how you can utilize building on the graph to enhance your AI agents. I'm really excited to see what you guys can build using the graph data. So without further ado, let's get started.

Okay, so again, uh we're going to be talking about the graph. We're going to be talking about indexing smart contract data. And uh again, my name is Kevin. I work in Devrell for the graph. I also support the Build guild working on scaffold eth. Uh but I'm really excited to have you guys here today. We're going to try to fly through this intro because uh I want to get to the nitty gritty and actually do a demo and maybe showcase um the power of the graph.

So first of all, uh we're going to talk about what the graph is, why it's important. We're going to talk about the configuration, the architecture, and then we're going to do a demo, okay? So first of all, why do we need data indexing?

So, for the most part, you can uh I think everyone here knows, uh you have a smart contract and you want users to create these transactions on your smart contract. Uh if you're a good smart contract developer, your smart contract emits events, right? And you you probably care about that stuff, right? That's stuff you want to keep track of. Um and uh if we think of a good example is like the cryptopunks NFT, right? It's very simple, it's just a list of IDs, cryptopunks, who their current owner is, and then the metadata URI, which is like the offchain data. And those owners change, right? As transfers happen, people buy punks or send them to their friends, if they're super rich, uh these events come off and we want to keep track of that stuff, right? So how do you get that stuff? Well, it's kind of hard uh on the blockchain, right? If you want to get the data that you care about, you're probably going to uh query it using an RPC, right? You're going to use it the the standard RPC. So it's very difficult to find exactly what you're looking for. I mean, yes, you can know the contract and you can kind of query for a specific um block, right? To get the data you need. But the minute you want to get like multiple uh protocols or if you want to get um large number of different transactions for a particular protocol, it gets a little hard to do. We also have this issue where the original idea for building a dap was that you would have a user interface, UX like uh HTML, JavaScript, CSS and you would read and write from the blockchain. Well, most blockchains are incentivized for rights, right? You pay gas to update the state of a variable and that's the security layer of the blockchain. But when it comes to reading data, it's not very effective to read from the blockchain. So what we really want is uh to speed that up and and and and we can do that with the graph. We'll get there.

Providence. We also don't know over time, like what has happened in any particular smart contract without knowing the exact block number and then going back and looking in time, and that's very hard to do. And so what we really want is something like time machine on the on the Mac, which is I guess still a thing, but you can go back in time and you can get changes to a particular smart contract, right? Or in our case, we want to know exactly what happened to the cryptopunks at a certain time. And so we also have this issue of like front-end developers, it's struggling trying to get the data they need from an RPC provider. They end up having to get it from an indexer because in order to get large amounts of information from different blocks and um you you might have to do something like this, which is actually code we saw in the wild where someone was trying to loop through and get all the uh NFTs in a wallet, which is fine if you only have a couple or a handful, but if you have lots of NFTs like me, um, you know, you're probably going to have issues uh loading my wallet with this code uh in their application. And so what we want is the graph. Uh the graph is the solution for a lot of issues when it comes to blockchain data. And the graph is a decentralized network of indexers that are serving data. There's over 200 indexers. Uh there's over 100,000 delegators providing stake to the network. There's over 10,000 sub graphs which are unique APIs that give access to blockchain data. And there's over 10,000 curators that are curating data and signaling for high quality sub graphs. And so this makes for a very robust and diverse uh uh network of uh infrastructure that the graph provides.

So we take this idea of a uh a huge number of uh transactions and wallets and stuff going on and we can consolidate this into what are called sub graphs, right? These are individual buckets that allow you to get access to that data in an easy to query way over graph QL. So the one of the most important factors of the graph is it utilizes graph QL. Uh graph QL is very, very powerful when it comes to getting lots of information because you can make one simple HTTP request and get lots of entities back with all of the data that you care about in one single request.

So we have this slow application. We can replace that read with an indexing protocol, a middleware layer that we call the graph and then we can provide that data uh in an easily and easily accessible, effective, fast way uh that's very friendly to interact with.

So, the config. What does it look like? Well, like any software, all softwares has a configuration file. That's what we call the manifest. It's the high level YAML configuration that keeps track of what network we care about, the contract address, how we want to uh configure the entities, how we want to handle the data as it comes off the blockchain. It references those two other entities and the wasm uh file, the handlers. The entities you can think of as um the schema file, like how do we want to store that data and expose it over graph QL, like what kind of data types are coming off of the events as they get stored into graph QL and exposed, or into the database and then exposed via graph QL. And then the handlers, which is the wasm, is what we call the mappings or the handlers and it's how we we actually process the data. So it's it's written in assembly script and it's compiled down into wasm code. Um the nice thing about this is it's very um secure focused, it's very fast, uh and it's a subset of TypeScript, so it has type support and it's very, very easy to work with. Um very, very powerful. And so all these kind of like tie together, the manifest, like I said is the the high level config that references the entities and the wasm, the the handlers.

So then, um as your application emits these events, and maybe these events have IPFS hashes or arweave hashes and we can go out and grab that offchain data as well, which is really powerful, or we can just index the event data and we can process it with wasm inside of the logic in those handlers. And then we can put that and store it on the indexer in a special database. Um and then when someone wants to come and query that data, they can make a high-level request over graph QL. Graph node, which is the powerhouse behind the graph, uh can go back and get the data it needs from the postgress database in a very highly optimized way and then serve that graph QL response over over the HTTP request.

And so what we're left with is is this. This is the architecture that we really want, right? Still the dap, HTML, CSS, JavaScript is the front end, is what we call the dap in this case. We're still proposing transactions to the smart contract. That smart contract is emitting events. Those events are being processed by the wasm module and then stored in the database in postgress. And then the graph node is then exposing that data via graph QL so that the front end can just query the graph QL API directly, the sub graph.

We also have a really good solution if you're new to building on Ethereum. This is a really great starting point. It's called the subgraph extension um for scaffold eth. Scaffold eth is a kit that comes with everything you need to build on Ethereum, a front end, a chain, and then the subgraph extension is just an added extension that allows you to um uh it's like a mono repo folder that keeps track of all the graph. Uh in this case, it's all running in Docker, so you can run a local first development, right? You can build your stuff locally, you can test locally, no need to deal with any test nets. Super powerful. Um you can get full access to the database and so it's really good for probably some of the projects you guys are going to be working on. Um and this is really easy to spin up. You just run that command on the bottom and it will give you the latest version of the subgraph. Um really, really powerful.

We also have a telegram chat. Please join. Uh there's a new channel for this hackathon. Go ahead and go in there and join. If you have questions, we'll also be in the discord. We have the the graph discord and then the ETH Global discord. Uh we'll be in both. Um I think this is probably the easiest way to get a hold of people because all of our support guys are in there and uh the Devrell, but uh we'll we'll keep an eye on on uh all of that. But if you have problems, please go here.

Now let's let's do a demo. So, we've been talking a little bit about uh cryptopunks. So I kind of want to uh start with this. So cryptopunks is a really cool NFT project. Obviously, I think everyone here probably knows about cryptopunks. They're little overpriced pictures that uh have sold for a lot of money. So if we look on this website, we say, oh well, the most expensive punk ever sold, largest sales, is 8,000 ETH, right? 23 million dollars. That's crazy. Um, but uh we let's see if we can validate that data with the graph, right? So, first of all, let's go to the graph.com and let's take a look. Uh what can we do here? Well, we have our our docs up here in the corner. So if you want to build a subgraph, you're going to want to go over here to quick start and it's going to walk you through everything you need to know to building a subgraph. Sub graphs are great for getting data from events. Uh and if you want to get more data, this might be like block data or you want to index things in a different way, um like maybe you want to get access to ordinals and you want to get access to like transfers, you probably want to look at sub streams. So there's a whole section on sub streams. I'm not going to dive too much into sub streams, but it's a good alternative way and you can also do sub streams powered sub graphs. So you can uh process the data using uh sub streams and then you can store it in a sub graph. So gives you a little more flexibility. But we're going to be focusing mainly on sub graphs today. Uh so let's go back to the website and come up here to products. There's two main products that you'll use if you're in the hackathon. You'll probably use either the explorer or the studio. If you want to find existing sub graphs that are already created, then this is the place to go. So you can see the most popular ones on the top here by curation signal. And so we use like some of the most popular ones. There's a test subgraph, which is just tracking how the network's operating. But then there's the Uniswap one and the substreams Uniswap powered subgraph, uh substreams powered subgraph. There's the snapshot, um UNCx, Live Peer. So if you're looking for existing data, come here first, see if there's already a subgraph and then use that subgraph. If it doesn't have the data you need, you want to build on top of it, then you'll probably want to create your own.

So let's assume we want to create our own. There's probably a cryptopunks one in here, but I'm going to want to build my own. So let's go over here to the top and let's instead go to the studio. So we're going to come to the studio. We're going to create a subgraph. So if it's the first time coming here, you might need to uh log in. I'm going to show you what that looks like, but you can click connect, choose Metamask, go ahead and sign, connect and sign your transaction and it will kind of bring you in here. Now, uh I already did this here, but I'm going to go ahead and walk through it. We'll create a new one. We'll call it CP, yeah, sure, crypto punk, CP. Hit enter and it's going to spin up like a an empty shell for us for to build a subgraph. So what do we need to do? Well, we can put in details here later. We don't care about that. But everything we need to set up the subgraph is down here on the corner. So, it's going to walk us through it. So the first thing we want to do is install the CLI. Okay? So we can use NPM or yarn. So let's do that. Let me go out of here, run a new terminal and let's do that. So, it might ask you to install a certain version of node. You need to use node version 20 or higher. I've already installed the CLI, so there's nothing new to install. Uh, next we can do a a graph and knit. So let's do that. So graph and knit, we'll kind of spin up an empty uh project for us, uh called CP. And then it's going to ask us what network we want to index. So you could search whatever. If you were looking for base, you could type base. If you were looking for, you know, whatever network, uh Zora, you know, if you were looking for Linia, you can type it in like that. We're going to use Ethereum main net because cryptopunks was a OG project. Um it asks us what we want to uh index. Is it a smart contract or do we want to use substreams? Really cool, you can use substreams, but for this one, we're just going to do a smart contract. Uh, we're going to name it CP. We're going to put it in a directory called CP. And then it wants the address. So let's go grab the address. I I just happen to grab it right here. We're going to get it from Etherscan, copy it, paste it in here. Now it's going to go out, it's going to fetch the ABI for us automatically. It's also going to fetch the start block. So, that's really important. You need the ABI because it's going to generate events off of the entities, um or entities off of the events, sorry, and it's going to need the start block because it you don't want to go all the way back to Genesis, right? You want to only index from the time of the you deployed the contract. So in this case, it's uh 3,914,495. And if you needed to get that, you can come here and look at the transaction to see what that is, but it's right here. Um, and then it's asks for the name of the contract. It also grabs that automatically. Enter. And then the last thing is it wants to index the events as entities. So we want to say yes, because we want to look at all the events and build out a subgraph automatically. So it's going to do that by going in and grabbing the ABI. If you for some reason didn't have the contract verified, you can manually give it the ABI and it will do that for you. Then it's going to empty create an empty repository. It's going to install the dependencies with yarn. It's going to generate the the types and it's going to generate all the code and it's going to uh make sure everything's good like syntax wise. And then it's going to ask you if you want to add another contract, which we're not. So we'll hit false. And then we're ready to go.

So now let's deploy it. Let's go back to here. We need to authenticate to the server. Go ahead and click authenticate. And then we need to uh go into the directory and then we need to run a codegen and build just one more time just to make sure that there's no type errors or any issues with the wasm uh being built. Nope, it's good. And then the very last step is to deploy it. So now we can deploy it. So you can see how easy it is. You just put in the contract address and as long as it's verified, it's going to do everything for you. You need to choose a version. So we're going to do version one. You can add the versions as you build, right? There we go. Now it's uh deploying and it's deployed. So let's go back here and let's look. All right, it's fully deployed. Because I've already deployed this one before in the past, we have it here. So we have the playground and we can hit play and we can already get data, right? It's working. We get the data, it's fully indexed. Now, the thing is is we want to look and uh at the punk sales. So we can come here to the graph QL explorer and look and look at all of the entities. Everything that's in the entities is going to be here. So, and it's very exploratory. So we can explore the punk bots. Let's get the first 10. Let's order by their value and let's get the ID, the index, who was to, who was from and the value. Yeah, sure. Hit play. Uh it's giving us value zero. So what we can do is order direction descending. Play. There we go. So now we can actually look here, the most expensive punk ever sold is 9998. Well, if we look here, that's not here at all. So what's going on? Well, if we look here, 9998, sorry, is right here, that's how much way it was. It comes out to like 124 ETH or something like that. It's a lot. So, um what's what's the thing? Well, you can look up on it, but this uh cryptopunk was a wash sale. So basically this sale is being censored on the cryptopunks website because they don't feel that it's an appropriate uh sale. Like it was basically bloated, the price was bloated. So you can kind of read up about it, but the whole point is that the data on the blockchain doesn't lie, right? We're able to get exactly what we need.

Um, so, uh if you're going to create a subgraph, uh you can come here to uh the subgraph studio, you can build one. If you want to use an existing one, you want to go to the explorer. If you're uh just new to the explorer or the studio, you can create a free API key with 100,000 queries. If you need a better API key, let us know, we can get you one if you run out of queries. Um uh what we're asking is for people to create uh the best use, essentially the best use of the graph in an AI agent. So, um just to give you guys some ideas, I've I've kind of come up with a couple ideas that I think would be interesting. First is if you're using base, uh maybe extending the CDP agent kit to uh integrate with some of our APIs, some of our sub graphs and that could be done maybe by um either adding capabilities and integrating with the Langchain tools. So you can do things like uh graph QL tool uh and integrating there. You could also maybe just uh use Langchain and you could uh use the graph QL Langchain tool that's available to get some data uh and define that uh custom tool that way. Or you can create your own tool with Langchain as well. So those are just a couple ideas to get you started. Um you could also run the the full stack and maybe like index some data and then do some like local kind of AI related stuff on it on your local machine. Uh maybe over a database. If you're using substreams, um didn't get too much into substreams, but if you can go on uh substreams website uh for uh streaming fast. Uh well here, introduction to substreams on the docs. Um, this is a different way of doing data processing. Um, it's a little more composable and you can output data to a database. Uh so if you want to like create your own substream, store it in a different database and maybe have your agent talk to that database, that's an option as well. But either way, we're looking for the the best use of the graph inside of an AI agent. So, we'll have three different prizes, first, second, and third. So we're excited to see what you build. Uh again, if you are just getting started, um and you need support or anything like that, please uh join the telegram here, uh reach out if you have any questions and uh really excited to see what you guys build and good luck and we'll see you uh in the future. Thank you.